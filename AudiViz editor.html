<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>AudiViz — Editor</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Bebas+Neue&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet"/>
  <style>
    *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
    :root{
      --panel:#0f0f0f;--panel2:#141414;--border:#1c1c1c;--border2:#252525;
      --cyan:#00e5ff;--cdim:rgba(0,229,255,.08);--cglow:rgba(0,229,255,.3);
      --white:#efefef;--muted:#444;--muted2:#777;--muted3:#aaa;
      --red:#ff4d4d;--amber:#ffaa00;--green:#00ff88;
      --sel:rgba(0,229,255,.12);--hover:rgba(255,255,255,.04);
      --TH:48px;--SH:22px;--TLH:44px;
    }
    html,body{height:100%;background:#000;color:var(--white);font-family:'DM Sans',sans-serif;font-size:13px;overflow:hidden;user-select:none}

    /* ── TOPBAR ── */
    #topbar{position:fixed;top:0;left:0;right:0;height:var(--TH);background:var(--panel);border-bottom:1px solid var(--border);display:flex;align-items:center;z-index:200;overflow:hidden}
    .tb-brand{display:flex;align-items:center;gap:10px;padding:0 18px;border-right:1px solid var(--border);height:100%;text-decoration:none;flex-shrink:0}
    .tb-logo{font-family:'Bebas Neue',sans-serif;font-size:22px;color:var(--white);letter-spacing:.03em}
    .tb-logo span{color:var(--cyan)}
    .tb-pname{display:flex;align-items:center;gap:8px;padding:0 14px;border-right:1px solid var(--border);height:100%;flex-shrink:0}
    .tb-pname input{background:none;border:none;outline:none;color:var(--white);font-family:'Space Mono',monospace;font-size:11px;letter-spacing:.05em;width:150px;user-select:text;-webkit-user-select:text}
    .tb-add{display:flex;align-items:center;gap:3px;padding:0 10px;border-right:1px solid var(--border);height:100%;overflow-x:auto;flex-shrink:0}
    .tb-add::-webkit-scrollbar{display:none}
    .add-lbl{font-family:'Space Mono',monospace;font-size:9px;letter-spacing:.2em;color:var(--muted2);text-transform:uppercase;margin-right:4px;white-space:nowrap;flex-shrink:0}
    .abtn{display:flex;align-items:center;gap:4px;padding:4px 8px;background:none;border:1px solid var(--border2);color:var(--muted3);font-family:'Space Mono',monospace;font-size:10px;cursor:pointer;white-space:nowrap;flex-shrink:0;clip-path:polygon(0 0,calc(100% - 5px) 0,100% 5px,100% 100%,0 100%);transition:border-color .15s,color .15s,background .15s}
    .abtn:hover{border-color:var(--cyan);color:var(--cyan);background:var(--cdim)}
    .abtn .dot{width:5px;height:5px;border-radius:50%;flex-shrink:0}
    .tb-right{display:flex;align-items:center;margin-left:auto;height:100%;flex-shrink:0}
    .tb-undoredo{display:flex;align-items:center;gap:2px;padding:0 10px;border-left:1px solid var(--border);height:100%}
    .urb{width:28px;height:28px;display:flex;align-items:center;justify-content:center;background:none;border:1px solid var(--border2);color:var(--muted3);cursor:pointer;transition:all .15s}
    .urb:hover:not(:disabled){border-color:var(--cyan);color:var(--cyan)}
    .urb:disabled{opacity:.3;cursor:default}
    .tb-play{display:flex;align-items:center;gap:4px;padding:0 12px;border-left:1px solid var(--border);height:100%}
    .pbtn{width:28px;height:28px;display:flex;align-items:center;justify-content:center;background:none;border:1px solid var(--border2);color:var(--muted3);cursor:pointer;transition:all .15s}
    .pbtn:hover{border-color:var(--cyan);color:var(--cyan)}
    .pbtn.active{background:var(--cyan);border-color:var(--cyan);color:#000}
    #timeDisp{font-family:'Space Mono',monospace;font-size:10px;color:var(--muted2);margin-left:6px;min-width:72px}
    .tb-actions{display:flex;align-items:center;gap:5px;padding:0 12px;border-left:1px solid var(--border);height:100%}
    .btn-sv{display:flex;align-items:center;gap:6px;background:none;border:1px solid var(--border2);color:var(--muted3);font-family:'Space Mono',monospace;font-size:10px;padding:6px 12px;cursor:pointer;transition:all .15s;white-space:nowrap}
    .btn-sv:hover{border-color:var(--green);color:var(--green)}
    .btn-svx{display:flex;align-items:center;gap:6px;background:none;border:1px solid var(--border2);color:var(--muted3);font-family:'Space Mono',monospace;font-size:10px;padding:6px 12px;cursor:pointer;transition:all .15s;white-space:nowrap}
    .btn-svx:hover{border-color:var(--amber);color:var(--amber)}
    .btn-exp{display:flex;align-items:center;gap:6px;background:var(--cyan);color:#000;border:none;font-family:'Space Mono',monospace;font-size:10px;font-weight:700;letter-spacing:.08em;text-transform:uppercase;padding:8px 14px;cursor:pointer;clip-path:polygon(0 0,calc(100% - 8px) 0,100% 8px,100% 100%,0 100%);transition:background .15s,box-shadow .15s;white-space:nowrap}
    .btn-exp:hover{background:#33ecff;box-shadow:0 0 20px var(--cglow)}

    /* ── STUDIO ── */
    #studio{position:fixed;top:var(--TH);left:0;right:0;bottom:calc(var(--SH) + var(--TLH));display:flex}
    .rh{width:4px;flex-shrink:0;background:var(--border);cursor:col-resize;position:relative;z-index:10;transition:background .15s}
    .rh::after{content:'';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:1px;height:32px;background:var(--muted);border-radius:1px}
    .rh:hover,.rh.drag{background:var(--cyan)}
    .rh:hover::after,.rh.drag::after{background:var(--cyan)}
    body.col-resize{cursor:col-resize}

    /* ── EXPLORER ── */
    #explorer{width:240px;min-width:140px;max-width:480px;background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden;flex-shrink:0}
    .ph{display:flex;align-items:center;justify-content:space-between;padding:9px 14px;border-bottom:1px solid var(--border);flex-shrink:0}
    .ptitle{font-family:'Space Mono',monospace;font-size:9px;letter-spacing:.25em;color:var(--muted2);text-transform:uppercase}
    .pbadge{font-family:'Space Mono',monospace;font-size:9px;color:var(--cyan);background:var(--cdim);padding:2px 7px;border:1px solid rgba(0,229,255,.15)}
    #node-tree{flex:1;overflow-y:auto;padding:6px 0}
    #node-tree::-webkit-scrollbar{width:3px}
    #node-tree::-webkit-scrollbar-thumb{background:var(--border2)}
    .ni{display:flex;align-items:center;gap:7px;padding:6px 14px 6px 18px;cursor:pointer;position:relative;transition:background .12s}
    .ni:hover{background:var(--hover)}
    .ni.sel{background:var(--sel)}
    .ni.sel::before{content:'';position:absolute;left:0;top:0;bottom:0;width:2px;background:var(--cyan)}
    .ni-icon{width:18px;height:18px;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:11px}
    .ni-lbl{flex:1;font-size:12px;color:var(--white);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ni-lock{color:var(--muted);flex-shrink:0}
    .ni-del{width:16px;height:16px;display:flex;align-items:center;justify-content:center;background:none;border:none;color:var(--muted);cursor:pointer;opacity:0;transition:opacity .15s,color .15s;flex-shrink:0}
    .ni:hover .ni-del{opacity:1}
    .ni-del:hover{color:var(--red)}
    .nsep{display:flex;align-items:center;gap:8px;padding:5px 14px;margin:3px 0}
    .nsep span{font-family:'Space Mono',monospace;font-size:8px;letter-spacing:.2em;color:var(--muted);text-transform:uppercase;white-space:nowrap}
    .nsep::before,.nsep::after{content:'';flex:1;height:1px;background:var(--border)}

    /* ── CANVAS ── */
    #canvas-area{flex:1;min-width:0;background:#060606;display:flex;flex-direction:column;overflow:hidden}
    .ctb{display:flex;align-items:center;gap:8px;padding:0 14px;height:36px;background:var(--panel);border-bottom:1px solid var(--border);flex-shrink:0}
    .ctb-label{font-family:'Space Mono',monospace;font-size:9px;color:var(--muted2);letter-spacing:.15em;text-transform:uppercase}
    .cres{font-family:'Space Mono',monospace;font-size:9px;color:var(--muted2);background:var(--panel2);border:1px solid var(--border);padding:3px 10px;cursor:default}
    /* Canvas preset picker */
    .preset-wrap{position:relative}
    .preset-btn{display:flex;align-items:center;gap:5px;padding:3px 10px;background:none;border:1px solid var(--border2);color:var(--muted3);font-family:'Space Mono',monospace;font-size:9px;cursor:pointer;transition:all .15s}
    .preset-btn:hover{border-color:var(--cyan);color:var(--cyan)}
    .preset-btn svg{flex-shrink:0;transition:transform .2s}
    .preset-btn.open svg{transform:rotate(180deg)}
    .preset-dropdown{position:absolute;top:calc(100% + 4px);left:0;background:var(--panel2);border:1px solid var(--border2);min-width:180px;z-index:100;box-shadow:0 8px 24px rgba(0,0,0,.6);display:none}
    .preset-dropdown.on{display:block}
    .preset-item{display:flex;align-items:center;gap:10px;padding:8px 14px;cursor:pointer;font-family:'Space Mono',monospace;font-size:10px;color:var(--muted3);transition:background .1s,color .1s}
    .preset-item:hover{background:var(--hover);color:var(--white)}
    .preset-item.active{color:var(--cyan)}
    .preset-thumb{width:22px;height:14px;border:1px solid currentColor;border-radius:1px;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:6px;opacity:.6}
    .cv-play{display:flex;align-items:center;gap:5px;padding:3px 10px;background:none;border:1px solid var(--border2);color:var(--muted3);font-family:'Space Mono',monospace;font-size:9px;cursor:pointer;transition:all .15s}
    .cv-play:hover{border-color:var(--cyan);color:var(--cyan)}
    .cv-play.on{background:var(--cyan);border-color:var(--cyan);color:#000}
    .cinfo{font-family:'Space Mono',monospace;font-size:9px;color:var(--muted2);letter-spacing:.08em;margin-left:auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .cvp{flex:1;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
    .cvp::before{content:'';position:absolute;inset:0;background-image:radial-gradient(circle,#1c1c1c 1px,transparent 1px);background-size:28px 28px;pointer-events:none}
    #cf{position:relative;background:#0a0a0a;border:1px solid var(--border2);box-shadow:0 0 0 1px var(--border),0 0 60px rgba(0,0,0,.8);overflow:hidden;flex-shrink:0;cursor:default}
    #cf::before,#cf::after{content:'';position:absolute;width:12px;height:12px;border-color:var(--cyan);border-style:solid;opacity:.5;z-index:20;pointer-events:none}
    #cf::before{top:-1px;left:-1px;border-width:1px 0 0 1px}
    #cf::after{bottom:-1px;right:-1px;border-width:0 1px 1px 0}
    #cbg{position:absolute;inset:0;background:#000;z-index:0}
    #cnodes{position:absolute;inset:0;z-index:1}
    #cdrag{position:absolute;inset:0;z-index:10;pointer-events:none}
    .dh{position:absolute;pointer-events:all;cursor:move;border:1.5px solid transparent;transition:border-color .1s}
    .dh:hover{border-color:rgba(0,229,255,.35)}
    .dh.active{border-color:var(--cyan);box-shadow:0 0 0 1px rgba(0,229,255,.18)}
    .dh.active .rz{display:block}
    .rz{display:none;position:absolute;width:8px;height:8px;background:var(--cyan);border:1px solid #000;z-index:2}
    .rz.nw{top:-4px;left:-4px;cursor:nw-resize}
    .rz.ne{top:-4px;right:-4px;cursor:ne-resize}
    .rz.sw{bottom:-4px;left:-4px;cursor:sw-resize}
    .rz.se{bottom:-4px;right:-4px;cursor:se-resize}

    /* ── TIMELINE ── */
    #timeline{position:fixed;bottom:var(--SH);left:0;right:0;height:var(--TLH);background:var(--panel);border-top:1px solid var(--border);display:flex;align-items:center;z-index:150}
    .tl-side{display:flex;align-items:center;gap:6px;padding:0 12px;height:100%;border-right:1px solid var(--border);flex-shrink:0}
    .tl-time{font-family:'Space Mono',monospace;font-size:10px;color:var(--cyan);min-width:38px}
    .tl-dur{font-family:'Space Mono',monospace;font-size:10px;color:var(--muted2)}
    .tl-track{flex:1;position:relative;height:100%;display:flex;align-items:center;padding:0 16px;cursor:pointer;overflow:hidden}
    .tl-bg{position:absolute;left:16px;right:16px;height:4px;background:var(--border2);border-radius:2px;pointer-events:none}
    .tl-fill{position:absolute;left:16px;height:4px;background:var(--cyan);border-radius:2px;pointer-events:none;width:0}
    .tl-head{position:absolute;width:14px;height:14px;background:var(--cyan);border-radius:50%;top:50%;transform:translate(-50%,-50%);cursor:grab;box-shadow:0 0 8px var(--cglow)}
    .tl-head:active{cursor:grabbing}
    .tl-waveform{position:absolute;left:16px;right:16px;height:22px;top:50%;transform:translateY(-50%);pointer-events:none;opacity:.25}

    /* ── PROPERTIES ── */
    #properties{width:270px;min-width:180px;max-width:520px;background:var(--panel);border-left:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden;flex-shrink:0}
    .props-body{flex:1;overflow-y:auto}
    .props-body::-webkit-scrollbar{width:3px}
    .props-body::-webkit-scrollbar-thumb{background:var(--border2)}
    .pempty{display:flex;flex-direction:column;align-items:center;justify-content:center;height:200px;gap:10px;padding:40px 20px;text-align:center}
    .pempty svg{opacity:.3}
    .pempty p{font-family:'Space Mono',monospace;font-size:10px;letter-spacing:.1em;color:var(--muted);line-height:1.7}
    .psec{margin-bottom:0}
    .psec-title{display:flex;align-items:center;gap:8px;padding:6px 14px;font-family:'Space Mono',monospace;font-size:9px;letter-spacing:.2em;color:var(--muted2);text-transform:uppercase;cursor:pointer;background:var(--panel2);border-top:1px solid var(--border);border-bottom:1px solid var(--border);user-select:none}
    .psec-title svg{transition:transform .2s;flex-shrink:0}
    .psec-title.col svg{transform:rotate(-90deg)}
    .psec-body{padding:2px 0}
    .psec-body.hid{display:none}
    .pr{display:grid;grid-template-columns:88px 1fr;align-items:center;gap:8px;padding:4px 14px;transition:background .1s}
    .pr:hover{background:var(--hover)}
    .pk{font-family:'Space Mono',monospace;font-size:10px;color:var(--muted2);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .pv input[type=text],.pv input[type=number],.pv select{width:100%;background:var(--panel2);border:1px solid var(--border);color:var(--white);font-family:'Space Mono',monospace;font-size:10px;padding:4px 7px;outline:none;transition:border-color .15s;user-select:text;-webkit-user-select:text}
    .pv input:focus,.pv select:focus{border-color:var(--cyan)}
    .pv select{cursor:pointer}
    .pv option{background:var(--panel2)}
    .pv input[type=color]{width:100%;height:26px;padding:2px;background:var(--panel2);border:1px solid var(--border);cursor:pointer}
    .pv input[type=range]{width:100%;accent-color:var(--cyan);cursor:pointer}
    .rwrap{display:flex;align-items:center;gap:7px}
    .rval{font-family:'Space Mono',monospace;font-size:10px;color:var(--muted3);min-width:42px;text-align:right;flex-shrink:0}
    .twrap{display:flex;align-items:center}
    .tgl{position:relative;width:32px;height:16px;cursor:pointer}
    .tgl input{display:none}
    .tgl-tr{width:100%;height:100%;background:var(--border2);border-radius:8px;transition:background .2s}
    .tgl input:checked~.tgl-tr{background:var(--cyan)}
    .tgl-th{position:absolute;top:2px;left:2px;width:12px;height:12px;background:var(--white);border-radius:50%;transition:left .2s}
    .tgl input:checked~.tgl-th{left:18px}
    .plock{display:flex;align-items:center;gap:8px;margin:8px 14px;padding:8px 10px;background:rgba(255,170,0,.05);border:1px solid rgba(255,170,0,.14);font-family:'Space Mono',monospace;font-size:9px;letter-spacing:.08em;color:var(--amber)}
    .pfbtn{display:flex;align-items:center;gap:6px;padding:5px 10px;background:none;border:1px solid var(--border2);color:var(--muted3);font-family:'Space Mono',monospace;font-size:9px;cursor:pointer;transition:border-color .15s,color .15s;width:100%}
    .pfbtn:hover{border-color:var(--cyan);color:var(--cyan)}
    .audio-loaded{font-family:'Space Mono',monospace;font-size:9px;color:var(--green);padding:3px 8px;background:rgba(0,255,136,.05);border:1px solid rgba(0,255,136,.14);margin-top:3px;display:none}

    /* dot colours */
    .dot-bar{background:#00e5ff}.dot-particle{background:#ff6bff}.dot-image{background:#ffaa00}
    .dot-text{background:#00ff88}.dot-shape{background:#ff7043}
    .dot-gradient{background:linear-gradient(135deg,#ff6bff,#00e5ff)}
    .dot-audio{background:#ffaa00}.dot-bg{background:#555}

    /* context menu */
    #ctx{position:fixed;background:var(--panel2);border:1px solid var(--border2);min-width:160px;z-index:999;display:none;box-shadow:0 8px 32px rgba(0,0,0,.6)}
    #ctx.on{display:block}
    .ci{display:flex;align-items:center;gap:10px;padding:8px 14px;cursor:pointer;font-size:12px;color:var(--muted3);transition:background .1s,color .1s}
    .ci:hover{background:var(--hover);color:var(--white)}
    .ci.danger{color:var(--red)}
    .ci.danger:hover{background:rgba(255,77,77,.08)}
    .csep{height:1px;background:var(--border);margin:4px 0}

    /* toast */
    #toast{position:fixed;bottom:40px;left:50%;transform:translateX(-50%) translateY(20px);background:var(--panel2);border:1px solid var(--border2);padding:10px 20px;font-family:'Space Mono',monospace;font-size:11px;color:var(--white);letter-spacing:.05em;z-index:500;opacity:0;transition:opacity .3s,transform .3s;pointer-events:none;box-shadow:0 8px 32px rgba(0,0,0,.6)}
    #toast.show{opacity:1;transform:translateX(-50%) translateY(0)}

    /* export modal */
    #expModal{position:fixed;inset:0;background:rgba(0,0,0,.88);backdrop-filter:blur(4px);z-index:400;display:none;align-items:center;justify-content:center}
    #expModal.on{display:flex}
    .exp-box{background:var(--panel2);border:1px solid rgba(0,229,255,.2);padding:40px;width:460px;clip-path:polygon(0 0,calc(100% - 20px) 0,100% 20px,100% 100%,0 100%)}
    .exp-title{font-family:'Bebas Neue',sans-serif;font-size:32px;color:var(--white);margin-bottom:4px}
    .exp-sub{font-family:'Space Mono',monospace;font-size:10px;color:var(--muted2);margin-bottom:24px;letter-spacing:.05em}
    .exp-bar-bg{height:4px;background:var(--border2);border-radius:2px;margin-bottom:14px}
    .exp-fill{height:100%;background:var(--cyan);border-radius:2px;width:0;transition:width .08s}
    .exp-pct{font-family:'Bebas Neue',sans-serif;font-size:32px;color:var(--cyan);margin-bottom:6px}
    .exp-status{font-family:'Space Mono',monospace;font-size:9px;color:var(--muted2);letter-spacing:.08em}
    .exp-note{font-family:'Space Mono',monospace;font-size:8px;color:var(--muted);margin-top:8px;letter-spacing:.05em;line-height:1.6}
    .exp-cancel{margin-top:22px;background:none;border:1px solid var(--border2);color:var(--muted3);font-family:'Space Mono',monospace;font-size:10px;padding:7px 18px;cursor:pointer;transition:all .15s}
    .exp-cancel:hover{border-color:var(--red);color:var(--red)}

    /* statusbar */
    #statusbar{position:fixed;bottom:0;left:0;right:0;height:var(--SH);background:var(--panel);border-top:1px solid var(--border);display:flex;align-items:center;padding:0 14px;gap:18px;z-index:200}
    .si{display:flex;align-items:center;gap:5px;font-family:'Space Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:.07em}
    .sdot{width:5px;height:5px;border-radius:50%}

    /* undo/redo indicator */
    #undoIndicator{position:fixed;top:60px;left:50%;transform:translateX(-50%);background:var(--panel2);border:1px solid var(--border2);padding:6px 16px;font-family:'Space Mono',monospace;font-size:10px;color:var(--muted3);z-index:300;opacity:0;transition:opacity .2s;pointer-events:none}
    #undoIndicator.show{opacity:1}
  </style>
</head>
<body>

<!-- TOPBAR -->
<div id="topbar">
  <a href="AudiViz home screen.html" class="tb-brand" id="homeLink">
    <div class="tb-logo">Audi<span>Viz</span></div>
  </a>
  <div class="tb-pname">
    <svg width="11" height="11" viewBox="0 0 12 12" fill="none" stroke="var(--muted2)" stroke-width="1.5" style="flex-shrink:0"><path d="M8 1.5l2 2L3 11H1v-2L8 1.5z"/></svg>
    <input type="text" id="projName" value="Untitled Project" spellcheck="false"/>
  </div>
  <div class="tb-add">
    <span class="add-lbl">Add</span>
    <button class="abtn" onclick="addNode('Visual Bar')"><span class="dot dot-bar"></span>Visual Bar</button>
    <button class="abtn" onclick="addNode('Particle')"><span class="dot dot-particle"></span>Particle</button>
    <button class="abtn" onclick="addNode('Image')"><span class="dot dot-image"></span>Image</button>
    <button class="abtn" onclick="addNode('Text')"><span class="dot dot-text"></span>Text</button>
    <button class="abtn" onclick="addNode('Shape')"><span class="dot dot-shape"></span>Shape</button>
    <button class="abtn" onclick="addNode('Gradient')"><span class="dot dot-gradient"></span>Gradient</button>
  </div>
  <div class="tb-right">
    <div class="tb-undoredo">
      <button class="urb" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)" disabled>
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><path d="M2 5H8a3 3 0 010 6H4"/><path d="M2 5L4 3M2 5l2 2"/></svg>
      </button>
      <button class="urb" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)" disabled>
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><path d="M10 5H4a3 3 0 000 6h4"/><path d="M10 5L8 3M10 5L8 7"/></svg>
      </button>
    </div>
    <div class="tb-play">
      <button class="pbtn" id="btnStop" onclick="stopPb()" title="Stop">
        <svg width="10" height="10" viewBox="0 0 10 10"><rect width="10" height="10" fill="currentColor"/></svg>
      </button>
      <button class="pbtn" id="btnPlay" onclick="togglePlay()" title="Play/Pause">
        <svg width="10" height="12" viewBox="0 0 10 12"><path d="M0 0l10 6-10 6V0z" fill="currentColor"/></svg>
      </button>
      <span id="timeDisp">0:00 / 0:00</span>
    </div>
    <div class="tb-actions">
      <button class="btn-sv" onclick="saveProject()">
        <svg width="11" height="11" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.4"><path d="M9 1H2a1 1 0 00-1 1v8a1 1 0 001 1h8a1 1 0 001-1V3L9 1z"/><rect x="3" y="7" width="6" height="4" rx=".5"/><rect x="4" y="1" width="4" height="3" rx=".5"/></svg>
        Save
      </button>
      <button class="btn-svx" onclick="saveAndExit()">
        <svg width="11" height="11" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.4"><path d="M5 2H2a1 1 0 00-1 1v7a1 1 0 001 1h8a1 1 0 001-1V7"/><path d="M8 1h3v3M11 1L6 6"/></svg>
        Save &amp; Exit
      </button>
      <button class="btn-exp" onclick="startExport()">
        <svg width="11" height="11" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M6 1v7M3 5l3 3 3-3M1 9v2h10V9"/></svg>
        Export
      </button>
    </div>
  </div>
</div>

<!-- STUDIO -->
<div id="studio">
  <div id="explorer">
    <div class="ph"><span class="ptitle">Explorer</span><span class="pbadge" id="nbadge">0</span></div>
    <div id="node-tree"></div>
  </div>
  <div class="rh" id="rhL"></div>

  <div id="canvas-area">
    <div class="ctb">
      <span class="ctb-label">Canvas</span>
      <span class="cres" id="cresLabel">1920 × 1080</span>
      <!-- Canvas size preset picker -->
      <div class="preset-wrap" id="presetWrap">
        <button class="preset-btn" id="presetBtn" onclick="togglePresetMenu()">
          <span id="presetLabel">YouTube 16:9</span>
          <svg width="8" height="5" viewBox="0 0 8 5" fill="currentColor"><path d="M0 0l4 5 4-5H0z"/></svg>
        </button>
        <div class="preset-dropdown" id="presetDropdown"></div>
      </div>
      <button class="cv-play" id="cvbtn" onclick="togglePlay()">
        <svg id="cvicon" width="8" height="10" viewBox="0 0 8 10"><path d="M0 0l8 5-8 5V0z" fill="currentColor"/></svg>
        <span id="cvlbl">Play</span>
      </button>
      <div class="cinfo" id="cinfo">Click · Drag to move · Corner to resize · Right-click options</div>
    </div>
    <div class="cvp" id="cvp">
      <div id="cf">
        <div id="cbg"></div>
        <div id="cnodes"></div>
        <div id="cdrag"></div>
      </div>
    </div>
  </div>

  <div class="rh" id="rhR"></div>
  <div id="properties">
    <div class="ph">
      <span class="ptitle">Properties</span>
      <span id="pnname" style="font-family:'Space Mono',monospace;font-size:9px;color:var(--cyan);letter-spacing:.1em"></span>
    </div>
    <div class="props-body" id="propsBody">
      <div class="pempty">
        <svg width="36" height="36" viewBox="0 0 36 36" fill="none" stroke="currentColor" stroke-width="1"><rect x="4" y="4" width="28" height="28" rx="2"/><path d="M4 12h28M12 4v28"/></svg>
        <p>Select a node in<br/>the Explorer to<br/>edit its properties</p>
      </div>
    </div>
  </div>
</div>

<!-- TIMELINE -->
<div id="timeline">
  <div class="tl-side">
    <button class="pbtn" onclick="stopPb()">
      <svg width="9" height="9" viewBox="0 0 9 9"><rect width="9" height="9" fill="currentColor"/></svg>
    </button>
    <button class="pbtn" id="tlPlay" onclick="togglePlay()">
      <svg width="8" height="10" viewBox="0 0 8 10" id="tlPlayIcon"><path d="M0 0l8 5-8 5V0z" fill="currentColor"/></svg>
    </button>
    <span class="tl-time" id="tlTime">0:00</span>
    <span class="tl-dur" id="tlDur">/ 0:00</span>
  </div>
  <div class="tl-track" id="tlTrack">
    <canvas class="tl-waveform" id="tlWave"></canvas>
    <div class="tl-bg"></div>
    <div class="tl-fill" id="tlFill"></div>
    <div class="tl-head" id="tlHead" style="left:16px"></div>
  </div>
</div>

<!-- STATUS BAR -->
<div id="statusbar">
  <div class="si"><span class="sdot" id="sdot" style="background:var(--green)"></span><span id="stxt">Ready</span></div>
  <div class="si" id="snodes">Nodes: 0</div>
  <div class="si" id="ssel">—</div>
  <div class="si" id="saudio" style="color:var(--muted)">No audio</div>
  <div class="si" style="margin-left:auto">AudiViz v0.2</div>
</div>

<!-- CONTEXT MENU -->
<div id="ctx">
  <div class="ci" id="cxRen">
    <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1.5l2 2L3 11H1v-2L8 1.5z"/></svg> Rename
  </div>
  <div class="ci" id="cxDup">
    <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="8" height="8" rx="1"/><path d="M1 9V1h8"/></svg> Duplicate
  </div>
  <div class="csep"></div>
  <div class="ci danger" id="cxDel">
    <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 3h8M4 3V2h4v1M5 5v4M7 5v4M3 3l.5 7h5l.5-7H3z"/></svg> Remove
  </div>
</div>

<div id="toast"></div>
<div id="undoIndicator"></div>

<!-- EXPORT MODAL -->
<div id="expModal">
  <div class="exp-box">
    <div class="exp-title">Exporting Video</div>
    <div class="exp-sub" id="expSub">Preparing…</div>
    <div class="exp-bar-bg"><div class="exp-fill" id="expFill"></div></div>
    <div class="exp-pct" id="expPct">0%</div>
    <div class="exp-status" id="expStatus">Initializing…</div>
    <div class="exp-note" id="expNote">The video will match your editor exactly — same canvas size, audio included.</div>
    <button class="exp-cancel" onclick="cancelExport()">Cancel</button>
  </div>
</div>

<script>
/* ══════════════════════════════════════════════
   CANVAS PRESETS
══════════════════════════════════════════════ */
const PRESETS = [
  { id:'youtube',   label:'YouTube 16:9',  w:1920, h:1080, thumb:'16:9' },
  { id:'square',    label:'Square 1:1',    w:1080, h:1080, thumb:'1:1'  },
  { id:'portrait',  label:'Portrait 4:5',  w:1080, h:1350, thumb:'4:5'  },
  { id:'tiktok',    label:'TikTok 9:16',   w:1080, h:1920, thumb:'9:16' },
  { id:'landscape', label:'Landscape 4:3', w:1440, h:1080, thumb:'4:3'  },
];
let NW = 1920, NH = 1080, currentPreset = 'youtube';
let CW = 854, CH = 480;

/* ══════════════════════════════════════════════
   STATE
══════════════════════════════════════════════ */
let nodes = [], selId = null, ctxId = null;
let playing = false, raf = null;
let nodeId = 10;
let projectId = null;
let interaction = null; // {type, id, corner, sx,sy, nx,ny, nw,nh}

/* ── Audio ── */
let audioCtx = null, audioSrc = null, gainNode = null, analyser = null, freqData = null;
let audioBuffer = null, audioStartTime = 0, audioDuration = 0, currentTime = 0;
let tlDragging = false;

/* ── Undo / Redo ── */
const history = [];
let histIdx = -1;

/* ══════════════════════════════════════════════
   UNDO / REDO
══════════════════════════════════════════════ */
function pushHistory() {
  // Trim any forward history
  history.splice(histIdx + 1);
  history.push(JSON.stringify({ nodes, preset: currentPreset }));
  if (history.length > 60) history.shift();
  histIdx = history.length - 1;
  updateUndoUI();
}

function undo() {
  if (histIdx <= 0) return;
  histIdx--;
  applyHistory();
  showUndoIndicator('Undo');
}

function redo() {
  if (histIdx >= history.length - 1) return;
  histIdx++;
  applyHistory();
  showUndoIndicator('Redo');
}

function applyHistory() {
  const state = JSON.parse(history[histIdx]);
  nodes = state.nodes;
  nodeId = Math.max(...nodes.map(n => n.id), 10) + 1;
  selId = null;
  if (state.preset && state.preset !== currentPreset) {
    applyPreset(state.preset, false);
  }
  renderTree(); renderCanvas(); renderProps(null); updateStatus(); updateUndoUI();
}

function updateUndoUI() {
  document.getElementById('undoBtn').disabled = histIdx <= 0;
  document.getElementById('redoBtn').disabled = histIdx >= history.length - 1;
}

let undoIndTimer = null;
function showUndoIndicator(label) {
  const el = document.getElementById('undoIndicator');
  el.textContent = label;
  el.classList.add('show');
  clearTimeout(undoIndTimer);
  undoIndTimer = setTimeout(() => el.classList.remove('show'), 800);
}

/* keyboard shortcuts */
document.addEventListener('keydown', e => {
  const meta = e.ctrlKey || e.metaKey;
  if (meta && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
  if (meta && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); redo(); }
  if (meta && e.key === 's') { e.preventDefault(); saveProject(); }
});

/* ══════════════════════════════════════════════
   CANVAS PRESETS
══════════════════════════════════════════════ */
function buildPresetMenu() {
  const dd = document.getElementById('presetDropdown');
  dd.innerHTML = PRESETS.map(p => `
    <div class="preset-item${p.id===currentPreset?' active':''}" data-pid="${p.id}" onclick="applyPreset('${p.id}',true)">
      <div class="preset-thumb">${p.thumb}</div>
      <span>${p.label}</span>
      <span style="font-family:'Space Mono',monospace;font-size:8px;color:var(--muted);margin-left:auto">${p.w}×${p.h}</span>
    </div>`).join('');
}

function togglePresetMenu() {
  const dd = document.getElementById('presetDropdown');
  const btn = document.getElementById('presetBtn');
  const open = dd.classList.toggle('on');
  btn.classList.toggle('open', open);
}

function applyPreset(id, withHistory = true) {
  const p = PRESETS.find(p => p.id === id); if (!p) return;
  currentPreset = id; NW = p.w; NH = p.h;
  document.getElementById('presetLabel').textContent = p.label;
  document.getElementById('cresLabel').textContent = `${NW} × ${NH}`;
  document.getElementById('presetDropdown').classList.remove('on');
  document.getElementById('presetBtn').classList.remove('open');
  buildPresetMenu();
  resizeCanvas(); renderCanvas();
  if (withHistory) pushHistory();
  toast(`Canvas: ${p.label} (${NW}×${NH})`);
}

document.addEventListener('click', e => {
  if (!document.getElementById('presetWrap').contains(e.target)) {
    document.getElementById('presetDropdown').classList.remove('on');
    document.getElementById('presetBtn').classList.remove('open');
  }
});

/* ══════════════════════════════════════════════
   PROJECT PERSISTENCE
══════════════════════════════════════════════ */
const params = new URLSearchParams(window.location.search);
projectId = params.get('id') || 'default';
const _pname = params.get('name');
if (_pname) document.getElementById('projName').value = _pname;

function saveProject(silent = false) {
  const data = JSON.stringify({ name: document.getElementById('projName').value, nodes, preset: currentPreset });
  localStorage.setItem('audiviz_project_' + projectId, data);
  try {
    const list = JSON.parse(localStorage.getItem('audiviz_projects')) || [];
    const i = list.findIndex(p => String(p.id) === String(projectId));
    if (i >= 0) { list[i].lastEdit = Date.now(); localStorage.setItem('audiviz_projects', JSON.stringify(list)); }
  } catch {}
  if (!silent) toast('✓ Saved');
}

function saveAndExit() { saveProject(true); window.location.href = 'AudiViz home screen.html'; }

document.getElementById('homeLink').addEventListener('click', e => {
  e.preventDefault();
  if (confirm('Save before leaving?')) saveProject(true);
  window.location.href = 'AudiViz home screen.html';
});
setInterval(() => saveProject(true), 30000);

/* ══════════════════════════════════════════════
   NODE DEFINITIONS
══════════════════════════════════════════════ */
const NT = {
  'Visual Bar': { icon:'▐▌', dot:'dot-bar', color:'#00e5ff', locked:false,
    def:{ label:'Visual Bar', visible:true, x:0, y:0, width:900, height:300,
          color:'#00e5ff', barCount:32, barGap:4, opacity:100,
          barType:'soft', formation:'line', maxHeight:280, intensity:70, rotation:0 }},
  'Particle': { icon:'✦', dot:'dot-particle', color:'#ff6bff', locked:false,
    def:{ label:'Particle', visible:true, x:0, y:0, count:60, speed:2, size:4, color:'#ff6bff', opacity:80 }},
  'Image': { icon:'⬜', dot:'dot-image', color:'#ffaa00', locked:false,
    def:{ label:'Image', visible:true, x:0, y:0, width:300, height:300, src:'', opacity:100 }},
  'Text': { icon:'Aa', dot:'dot-text', color:'#00ff88', locked:false,
    def:{ label:'Text', visible:true, x:0, y:0, width:400, height:80, content:'Hello World', fontSize:72, fontFamily:'Space Mono', color:'#ffffff', opacity:100, align:'center' }},
  'Shape': { icon:'◆', dot:'dot-shape', color:'#ff7043', locked:false,
    def:{ label:'Shape', visible:true, x:0, y:0, width:240, height:240, shape:'rectangle', color:'#ff7043', opacity:100, borderRadius:0 }},
  'Gradient': { icon:'◑', dot:'dot-gradient', color:'#aa44ff', locked:false,
    def:{ label:'Gradient', visible:true, x:0, y:0, width:1920, height:1080, colorA:'#ff6bff', colorB:'#00e5ff', direction:'horizontal', opacity:50 }},
  'Audio': { icon:'♪', dot:'dot-audio', color:'#ffaa00', locked:true,
    def:{ label:'Audio', src:'', volume:80, speed:1.0, pitchSync:true, reverse:false, cutStart:0, cutEnd:0 }},
  'Background': { icon:'▣', dot:'dot-bg', color:'#555', locked:true,
    def:{ label:'Background', src:'', blur:0, brightness:100, saturation:100, contrast:100 }},
};

/* ══════════════════════════════════════════════
   INIT
══════════════════════════════════════════════ */
function init() {
  // Load saved project
  const raw = localStorage.getItem('audiviz_project_' + projectId);
  if (raw) {
    try {
      const data = JSON.parse(raw);
      if (data.name) document.getElementById('projName').value = data.name;
      if (data.nodes) nodes = data.nodes;
      if (data.preset) applyPreset(data.preset, false);
      nodeId = Math.max(...nodes.map(n => n.id), 10) + 1;
      // Re-load audio if saved
      const an = nodes.find(n => n.type === 'Audio');
      if (an && an.props.src) loadAudioBuffer(an.props.src).catch(() => {});
    } catch {}
  }
  if (!nodes.length) {
    nodes = [
      { id:1, type:'Background', locked:true, props:{...NT['Background'].def} },
      { id:2, type:'Audio',      locked:true, props:{...NT['Audio'].def} },
    ];
  }
  nodeId = Math.max(...nodes.map(n => n.id), 10) + 1;
  buildPresetMenu();
  resizeCanvas(); renderTree(); renderCanvas(); updateStatus();
  setupPointer(); setupTimeline();
  pushHistory(); // initial state
}

/* ══════════════════════════════════════════════
   CANVAS SIZING
══════════════════════════════════════════════ */
function resizeCanvas() {
  const vp = document.getElementById('cvp'); if (!vp) return;
  const vpW = vp.clientWidth - 40, vpH = vp.clientHeight - 40;
  const r = NW / NH; let w = vpW, h = vpW / r;
  if (h > vpH) { h = vpH; w = vpH * r; }
  CW = Math.max(100, Math.round(w)); CH = Math.max(56, Math.round(h));
  const f = document.getElementById('cf');
  if (f) { f.style.width = CW + 'px'; f.style.height = CH + 'px'; }
}
window.addEventListener('resize', () => { resizeCanvas(); renderCanvas(); });

/* ══════════════════════════════════════════════
   NODE MANAGEMENT
══════════════════════════════════════════════ */
function addNode(type) {
  pushHistory();
  const d = NT[type]; if (!d) return;
  const label = type + ' ' + (nodes.filter(n => n.type === type).length + 1);
  const n = { id:++nodeId, type, locked:false, props:{...d.def, label} };
  nodes.push(n); selectNode(n.id); renderTree(); renderCanvas(); updateStatus();
}
function deleteNode(id) {
  const n = nodes.find(n => n.id === id); if (!n || n.locked) return;
  pushHistory();
  nodes = nodes.filter(n => n.id !== id);
  if (selId === id) { selId = null; renderProps(null); }
  renderTree(); renderCanvas(); updateStatus();
}
function dupeNode(id) {
  const n = nodes.find(n => n.id === id); if (!n || n.locked) return;
  pushHistory();
  const c = { id:++nodeId, type:n.type, locked:false, props:{...n.props, label:n.props.label+' (copy)', x:n.props.x+30, y:n.props.y+30} };
  nodes.push(c); selectNode(c.id); renderTree(); renderCanvas(); updateStatus();
}
function selectNode(id) {
  selId = id;
  const n = nodes.find(n => n.id === id);
  renderProps(n);
  document.querySelectorAll('.ni').forEach(el => el.classList.toggle('sel', parseInt(el.dataset.id) === id));
  document.getElementById('ssel').textContent = n ? n.props.label : '—';
  document.getElementById('cinfo').textContent = n ? `${n.props.label} — drag:move · corner:resize` : 'Click · Drag to move · Corner to resize · Right-click options';
  renderDragHandles();
}

/* ══════════════════════════════════════════════
   RENDER TREE
══════════════════════════════════════════════ */
function renderTree() {
  const tree = document.getElementById('node-tree');
  const locked = nodes.filter(n => n.locked), free = nodes.filter(n => !n.locked);
  let h = `<div class="nsep"><span>Scene</span></div>`;
  locked.forEach(n => {
    const d = NT[n.type];
    h += `<div class="ni${selId===n.id?' sel':''}" data-id="${n.id}" onclick="selectNode(${n.id})">
      <div class="ni-icon" style="color:${d.color}">${d.icon}</div>
      <span class="ni-lbl">${n.props.label}</span>
      <svg class="ni-lock" width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="2.5" y="4.5" width="5" height="4.5" rx=".5"/><path d="M3.5 4.5V3a1.5 1.5 0 013 0v1.5"/></svg>
    </div>`;
  });
  if (free.length) {
    h += `<div class="nsep"><span>Layers</span></div>`;
    [...free].reverse().forEach(n => {
      const d = NT[n.type];
      h += `<div class="ni${selId===n.id?' sel':''}" data-id="${n.id}" onclick="selectNode(${n.id})" oncontextmenu="openCtx(event,${n.id})">
        <div class="ni-icon" style="color:${d.color}">${d.icon}</div>
        <span class="ni-lbl">${n.props.label}</span>
        <button class="ni-del" onclick="event.stopPropagation();deleteNode(${n.id})">
          <svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 2l6 6M8 2l-6 6"/></svg>
        </button>
      </div>`;
    });
  }
  tree.innerHTML = h;
  document.getElementById('nbadge').textContent = nodes.length;
}

/* ══════════════════════════════════════════════
   DRAG HANDLES + RESIZE CORNERS
══════════════════════════════════════════════ */
function getNodeBounds(node) {
  const p = node.props, sX = CW/NW, sY = CH/NH;
  const w = (p.width  || 120) * sX;
  const h = (p.height || 80)  * sY;
  return { left: CW/2 + p.x*sX - w/2, top: CH/2 + p.y*sY - h/2, w, h };
}

function renderDragHandles() {
  const layer = document.getElementById('cdrag'); layer.innerHTML = '';
  nodes.filter(n => !n.locked && n.props.visible).forEach(node => {
    const { left, top, w, h } = getNodeBounds(node);
    const div = document.createElement('div');
    div.className = 'dh' + (selId === node.id ? ' active' : '');
    div.dataset.id = node.id;
    div.style.cssText = `left:${left}px;top:${top}px;width:${w}px;height:${h}px`;
    ['nw','ne','sw','se'].forEach(c => {
      const rz = document.createElement('div');
      rz.className = 'rz ' + c; rz.dataset.corner = c;
      div.appendChild(rz);
    });
    div.addEventListener('mousedown', e => {
      e.preventDefault(); e.stopPropagation();
      selectNode(node.id);
      const corner = e.target.dataset?.corner;
      interaction = corner
        ? { type:'resize', id:node.id, corner, sx:e.clientX, sy:e.clientY, nx:node.props.x, ny:node.props.y, nw:node.props.width||120, nh:node.props.height||80 }
        : { type:'move',   id:node.id, sx:e.clientX, sy:e.clientY, nx:node.props.x, ny:node.props.y };
      document.getElementById('cf').style.cursor = corner ? corner+'-resize' : 'grabbing';
    });
    div.addEventListener('contextmenu', e => openCtx(e, node.id));
    layer.appendChild(div);
  });
}

/* ══════════════════════════════════════════════
   POINTER (move + resize)
══════════════════════════════════════════════ */
function setupPointer() {
  document.addEventListener('mousemove', e => {
    if (!interaction) return;
    const node = nodes.find(n => n.id === interaction.id); if (!node) return;
    const sX = NW/CW, sY = NH/CH;
    const dx = (e.clientX - interaction.sx) * sX;
    const dy = (e.clientY - interaction.sy) * sY;
    if (interaction.type === 'move') {
      node.props.x = Math.round(interaction.nx + dx);
      node.props.y = Math.round(interaction.ny + dy);
    } else {
      const c = interaction.corner;
      let dw=0, dh=0, ddx=0, ddy=0;
      if (c.includes('e')) dw =  dx;
      if (c.includes('w')) { dw = -dx; ddx = dx; }
      if (c.includes('s')) dh =  dy;
      if (c.includes('n')) { dh = -dy; ddy = dy; }
      node.props.width  = Math.max(20, Math.round(interaction.nw + dw));
      node.props.height = Math.max(20, Math.round(interaction.nh + dh));
      node.props.x = Math.round(interaction.nx + ddx/2);
      node.props.y = Math.round(interaction.ny + ddy/2);
    }
    renderCanvas(); renderDragHandles();
    ['x','y','width','height'].forEach(k => {
      const el = document.querySelector(`[data-prop="${k}"]`);
      if (el && node.props[k] !== undefined) el.value = node.props[k];
    });
  });

  document.addEventListener('mouseup', () => {
    if (interaction) {
      pushHistory(); // push after drag/resize ends
      interaction = null;
      document.getElementById('cf').style.cursor = 'default';
    }
  });

  document.getElementById('cf').addEventListener('mousedown', e => {
    if (e.target.id === 'cf' || e.target.id === 'cnodes' || e.target.id === 'cbg') {
      selId = null; renderProps(null); renderDragHandles();
      document.querySelectorAll('.ni').forEach(el => el.classList.remove('sel'));
      document.getElementById('ssel').textContent = '—';
    }
  });
}

/* ══════════════════════════════════════════════
   AUDIO ENGINE
══════════════════════════════════════════════ */
function getAudioNode() { return nodes.find(n => n.type === 'Audio'); }

function initAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.8;
    freqData = new Uint8Array(analyser.frequencyBinCount);
    gainNode = audioCtx.createGain();
    gainNode.connect(analyser);
    analyser.connect(audioCtx.destination);
  }
}

async function loadAudioBuffer(dataUrl) {
  initAudioCtx();
  if (audioCtx.state === 'suspended') await audioCtx.resume();
  const res = await fetch(dataUrl);
  const ab  = await res.arrayBuffer();
  audioBuffer = await audioCtx.decodeAudioData(ab);
  audioDuration = audioBuffer.duration;
  updateTimelineWaveform();
  updateTimeDisplay();
  document.getElementById('saudio').textContent = `Audio: ${audioDuration.toFixed(1)}s`;
  document.getElementById('saudio').style.color = 'var(--green)';
  return audioBuffer;
}

function playAudio(offset = 0) {
  if (!audioBuffer || !audioCtx) return;
  stopAudioSrc();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  audioSrc = audioCtx.createBufferSource();
  audioSrc.buffer = audioBuffer;
  const an = getAudioNode();
  audioSrc.playbackRate.value = an ? an.props.speed : 1;
  audioSrc.connect(gainNode);
  gainNode.gain.value = an ? an.props.volume / 100 : 0.8;
  audioSrc.start(0, Math.max(0, Math.min(offset, audioDuration - 0.001)));
  audioStartTime = audioCtx.currentTime - offset;
}
function stopAudioSrc() {
  if (audioSrc) { try { audioSrc.stop(); } catch {} audioSrc = null; }
}
function getAudioCurrentTime() {
  if (!audioCtx || !playing) return currentTime;
  return Math.max(0, audioCtx.currentTime - audioStartTime);
}

/* ══════════════════════════════════════════════
   TIMELINE
══════════════════════════════════════════════ */
function setupTimeline() {
  const track = document.getElementById('tlTrack');
  function seekTo(x) {
    const rect = track.getBoundingClientRect(), pad = 16;
    const ratio = Math.max(0, Math.min(1, (x - rect.left - pad) / (rect.width - pad*2)));
    currentTime = ratio * (audioDuration || 60);
    updateTimeDisplay(); updateTimelineHead();
    if (playing) { stopAudioSrc(); playAudio(currentTime); }
  }
  track.addEventListener('mousedown', e => { if (e.target.id === 'tlHead') return; tlDragging = true; seekTo(e.clientX); });
  document.getElementById('tlHead').addEventListener('mousedown', e => { e.stopPropagation(); tlDragging = true; });
  document.addEventListener('mousemove', e => { if (tlDragging) seekTo(e.clientX); });
  document.addEventListener('mouseup',   () => { tlDragging = false; });
}

const fmt = t => `${Math.floor(t/60)}:${String(Math.floor(t%60)).padStart(2,'0')}`;

function updateTimeDisplay() {
  const cur = Math.min(currentTime, audioDuration||0);
  document.getElementById('tlTime').textContent = fmt(cur);
  document.getElementById('tlDur').textContent  = `/ ${fmt(audioDuration||0)}`;
  document.getElementById('timeDisp').textContent = `${fmt(cur)} / ${fmt(audioDuration||0)}`;
}

function updateTimelineHead() {
  const track = document.getElementById('tlTrack'), pad = 16;
  const tw = track.clientWidth - pad*2;
  const ratio = audioDuration > 0 ? Math.min(1, currentTime / audioDuration) : 0;
  const px = pad + ratio * tw;
  document.getElementById('tlHead').style.left = px + 'px';
  document.getElementById('tlFill').style.width = (px - pad) + 'px';
}

function updateTimelineWaveform() {
  if (!audioBuffer) return;
  const canvas = document.getElementById('tlWave');
  const track  = document.getElementById('tlTrack');
  canvas.width = Math.max(100, track.clientWidth - 32); canvas.height = 22;
  const ctx = canvas.getContext('2d'), data = audioBuffer.getChannelData(0);
  const step = Math.max(1, Math.floor(data.length / canvas.width));
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 1;
  const mid = canvas.height / 2;
  for (let x = 0; x < canvas.width; x++) {
    let mx = 0;
    for (let j = 0; j < step; j++) mx = Math.max(mx, Math.abs(data[x*step+j]||0));
    const h = mx * mid;
    ctx.beginPath(); ctx.moveTo(x, mid-h); ctx.lineTo(x, mid+h); ctx.stroke();
  }
}

/* ══════════════════════════════════════════════
   PLAYBACK
══════════════════════════════════════════════ */
function togglePlay() { if (!playing) startPlay(); else pausePlay(); }

function startPlay() {
  initAudioCtx();
  playing = true;
  playAudio(currentTime);
  setPlayUI(true);
  tickAV();
}
function pausePlay() {
  playing = false; stopAudioSrc();
  currentTime = getAudioCurrentTime();
  if (raf) { cancelAnimationFrame(raf); raf = null; }
  setPlayUI(false); updateTimeDisplay(); updateTimelineHead();
}
function stopPb() {
  playing = false; stopAudioSrc();
  currentTime = 0;
  if (raf) { cancelAnimationFrame(raf); raf = null; }
  setPlayUI(false); updateTimeDisplay(); updateTimelineHead();
  nodes.filter(n => n.type==='Visual Bar' && n.props.visible).forEach(n => {
    const c = document.getElementById(`vb-${n.id}`); if (c) drawVBar(c, n, 0, null);
  });
}
function setPlayUI(on) {
  ['btnPlay','cvbtn','tlPlay'].forEach(id => document.getElementById(id).classList.toggle('active', on));
  const pause = `<svg width="10" height="12" viewBox="0 0 10 12"><rect x="0" y="0" width="3" height="12" fill="currentColor"/><rect x="6" y="0" width="3" height="12" fill="currentColor"/></svg>`;
  const play  = `<svg width="10" height="12" viewBox="0 0 10 12"><path d="M0 0l10 6-10 6V0z" fill="currentColor"/></svg>`;
  document.getElementById('btnPlay').innerHTML = on ? pause : play;
  const tlI = document.getElementById('tlPlayIcon');
  tlI.outerHTML = on
    ? `<svg width="10" height="12" viewBox="0 0 10 12" id="tlPlayIcon"><rect x="0" y="0" width="3" height="12" fill="currentColor"/><rect x="6" y="0" width="3" height="12" fill="currentColor"/></svg>`
    : `<svg width="8" height="10" viewBox="0 0 8 10" id="tlPlayIcon"><path d="M0 0l8 5-8 5V0z" fill="currentColor"/></svg>`;
  const cvI = document.getElementById('cvicon');
  cvI.setAttribute('viewBox', on ? '0 0 8 8' : '0 0 8 10');
  cvI.innerHTML = on ? `<rect width="8" height="8" fill="currentColor"/>` : `<path d="M0 0l8 5-8 5V0z" fill="currentColor"/>`;
  document.getElementById('cvlbl').textContent = on ? 'Stop' : 'Play';
  document.getElementById('sdot').style.background  = on ? '#ff4d4d' : 'var(--green)';
  document.getElementById('stxt').textContent = on ? 'Playing' : 'Ready';
}
function tickAV() {
  if (!playing) return;
  currentTime = getAudioCurrentTime();
  if (audioDuration > 0 && currentTime >= audioDuration) { stopPb(); return; }
  if (analyser && freqData) analyser.getByteFrequencyData(freqData);
  nodes.filter(n => n.type==='Visual Bar' && n.props.visible).forEach(n => {
    const c = document.getElementById(`vb-${n.id}`); if (c) drawVBar(c, n, currentTime, freqData);
  });
  updateTimeDisplay(); updateTimelineHead();
  raf = requestAnimationFrame(tickAV);
}

/* ══════════════════════════════════════════════
   VISUAL BAR DRAWING
══════════════════════════════════════════════ */
function hexRgb(hex) {
  const h = (hex && hex.length===7) ? hex : '#00e5ff';
  return `${parseInt(h.slice(1,3),16)},${parseInt(h.slice(3,5),16)},${parseInt(h.slice(5,7),16)}`;
}

/* Shared bar renderer — works for both preview canvas and export canvas.
   canvasW/canvasH = actual canvas pixel size,
   designW/designH = the design space (NW×NH or export dims) */
function drawVBarToCanvas(ctx, p, freq, canvasW, canvasH, designW, designH) {
  const sX = canvasW / designW, sY = canvasH / designH;
  const count = Math.max(1, Math.min(256, Math.round(p.barCount)));
  const gap   = p.barGap * sX;
  const maxH  = p.maxHeight * sY;
  const rgb   = hexRgb(p.color);
  ctx.globalAlpha = p.opacity / 100;

  const heights = new Float32Array(count);
  if (freq && freq.length > 0) {
    const shift  = Math.round((p.rotation / 100) * freq.length);
    const binPer = freq.length / count;
    for (let i = 0; i < count; i++) {
      const idx = Math.floor(((i * binPer) + shift) % freq.length);
      heights[i] = Math.min(1, (freq[idx] / 255) * (p.intensity / 100));
    }
  }

  const cx = canvasW/2 + p.x*sX, cy = canvasH/2 + p.y*sY;

  if (p.formation === 'line') {
    const totalW = p.width * sX;
    const barW   = Math.max(1, (totalW - gap*(count-1)) / count);
    const startX = cx - totalW/2;
    for (let i = 0; i < count; i++) {
      let h = heights[i] * maxH;
      if (p.barType==='tower') h = h < maxH*.1 ? 0 : h * 1.5;
      const bh = Math.max(p.barType==='tower' ? 0 : 1, h); if (bh < 1) continue;
      const x = startX + i*(barW+gap);
      const g = ctx.createLinearGradient(x, cy-bh, x, cy);
      g.addColorStop(0, `rgba(${rgb},1)`); g.addColorStop(1, `rgba(${rgb},.1)`);
      ctx.fillStyle = g;
      if (p.barType==='soft') {
        const r = Math.min(barW/2, bh/2, 5*sX);
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(x, cy-bh, barW, bh, [r,r,0,0]); else ctx.rect(x, cy-bh, barW, bh);
        ctx.fill();
      } else if (p.barType==='wave') {
        ctx.beginPath(); ctx.ellipse(x+barW/2, cy-bh, barW/2, Math.min(barW/2,bh*.3), 0, Math.PI, 0);
        ctx.rect(x, cy-bh, barW, bh); ctx.fill();
      } else {
        ctx.fillRect(x, cy-bh, barW, bh);
        if (p.barType==='tower' && bh>3) { ctx.fillStyle=`rgba(${rgb},1)`; ctx.fillRect(x, cy-bh-2, barW, 2); }
      }
    }
  } else {
    const radius = Math.min(p.width, p.height) * Math.min(sX, sY) / 2;
    const barW   = Math.max(1.5, (2*Math.PI*radius/count) * .55);
    for (let i = 0; i < count; i++) {
      let h = heights[i] * maxH * .5;
      if (p.barType==='tower') h = h < maxH*.05 ? 0 : h*1.5;
      const bh = Math.max(p.barType==='tower'?0:1, h);
      const angle = (i/count)*Math.PI*2 - Math.PI/2;
      ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle);
      const g = ctx.createLinearGradient(0, -(radius+bh), 0, -radius);
      g.addColorStop(0, `rgba(${rgb},1)`); g.addColorStop(1, `rgba(${rgb},.2)`);
      ctx.fillStyle = g;
      const bx = -barW/2, by = -(radius+bh);
      if (p.barType==='soft') {
        const r = Math.min(barW/2, bh/2, 3); ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(bx, by, barW, bh, [r,r,0,0]); else ctx.rect(bx, by, barW, bh);
        ctx.fill();
      } else { if (bh>0) ctx.fillRect(bx, by, barW, bh); }
      ctx.restore();
    }
  }
  ctx.globalAlpha = 1;
}

/* Preview wrapper */
function drawVBar(canvas, node, t, realFreq) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawVBarToCanvas(ctx, node.props, realFreq, CW, CH, NW, NH);
}

/* ══════════════════════════════════════════════
   RENDER CANVAS
══════════════════════════════════════════════ */
function renderCanvas() {
  const sX = CW/NW, sY = CH/NH;
  // Background
  const bg = nodes.find(n => n.type==='Background'), bgEl = document.getElementById('cbg');
  if (bg) {
    bgEl.style.background = bg.props.src ? `url(${bg.props.src}) center/cover no-repeat` : '#000';
    const fp=[];
    if (bg.props.blur>0)           fp.push(`blur(${bg.props.blur}px)`);
    if (bg.props.brightness!==100) fp.push(`brightness(${bg.props.brightness}%)`);
    if (bg.props.saturation!==100) fp.push(`saturate(${bg.props.saturation}%)`);
    if (bg.props.contrast!==100)   fp.push(`contrast(${bg.props.contrast}%)`);
    bgEl.style.filter = fp.join(' ') || 'none';
  }
  const container = document.getElementById('cnodes'); container.innerHTML = '';
  nodes.filter(n => !n.locked).forEach(node => {
    if (!node.props.visible) return;
    const p = node.props;
    const cx = CW/2 + p.x*sX, cy = CH/2 + p.y*sY;
    let el = null;
    if (node.type === 'Visual Bar') {
      const cvs = document.createElement('canvas');
      cvs.id = `vb-${node.id}`; cvs.width = CW; cvs.height = CH;
      cvs.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;pointer-events:none;';
      container.appendChild(cvs);
      drawVBar(cvs, node, currentTime, playing ? freqData : null);
      return;
    }
    if (node.type === 'Text') {
      const w=(p.width||400)*sX, h=(p.height||80)*sY;
      el = document.createElement('div');
      el.style.cssText = `position:absolute;left:${cx-w/2}px;top:${cy-h/2}px;width:${w}px;height:${h}px;
        overflow:hidden;display:flex;align-items:center;
        justify-content:${p.align==='left'?'flex-start':p.align==='right'?'flex-end':'center'};
        font-size:${p.fontSize*sX}px;color:${p.color};opacity:${p.opacity/100};
        font-family:'${p.fontFamily}',monospace;white-space:nowrap;pointer-events:none;`;
      el.textContent = p.content;
    } else if (node.type === 'Shape') {
      const w=p.width*sX, h=p.height*sY;
      el = document.createElement('div');
      el.style.cssText = `position:absolute;left:${cx-w/2}px;top:${cy-h/2}px;width:${w}px;height:${h}px;
        background:${p.color};border-radius:${p.borderRadius}%;opacity:${p.opacity/100};pointer-events:none;`;
    } else if (node.type === 'Gradient') {
      const dirs = {horizontal:'to right',vertical:'to bottom',diagonal:'135deg'};
      const w=p.width*sX, h=p.height*sY;
      el = document.createElement('div');
      el.style.cssText = `position:absolute;left:${cx-w/2}px;top:${cy-h/2}px;width:${w}px;height:${h}px;
        background:linear-gradient(${dirs[p.direction]||'to right'},${p.colorA},${p.colorB});
        opacity:${p.opacity/100};pointer-events:none;`;
    } else if (node.type === 'Particle') {
      el = document.createElement('div');
      el.style.cssText = 'position:absolute;inset:0;pointer-events:none;overflow:hidden;';
      for (let i = 0; i < Math.min(p.count,80); i++) {
        const pt = document.createElement('div'); const s = p.size*sX;
        pt.style.cssText = `position:absolute;left:${Math.random()*100}%;top:${Math.random()*100}%;
          width:${s}px;height:${s}px;background:${p.color};border-radius:50%;
          opacity:${(p.opacity/100)*(.3+Math.random()*.7)};`;
        el.appendChild(pt);
      }
    } else if (node.type === 'Image') {
      const w=p.width*sX, h=p.height*sY;
      el = document.createElement('div');
      el.style.cssText = `position:absolute;left:${cx-w/2}px;top:${cy-h/2}px;width:${w}px;height:${h}px;
        background:${p.src?`url(${p.src}) center/cover no-repeat`:'rgba(255,170,0,.08)'};
        border:1px dashed rgba(255,170,0,.3);opacity:${p.opacity/100};pointer-events:none;`;
    } else {
      el = document.createElement('div');
      el.style.cssText = `position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
        width:48px;height:48px;border:1px dashed var(--border2);display:flex;align-items:center;
        justify-content:center;font-size:16px;color:${NT[node.type]?.color||'#fff'};pointer-events:none;`;
      el.textContent = NT[node.type]?.icon || '?';
    }
    if (el) container.appendChild(el);
  });
  renderDragHandles();
}

/* ══════════════════════════════════════════════
   RENDER PROPERTIES
══════════════════════════════════════════════ */
function renderProps(node) {
  const body = document.getElementById('propsBody'), lbl = document.getElementById('pnname');
  if (!node) {
    lbl.textContent = '';
    body.innerHTML = `<div class="pempty"><svg width="36" height="36" viewBox="0 0 36 36" fill="none" stroke="currentColor" stroke-width="1"><rect x="4" y="4" width="28" height="28" rx="2"/><path d="M4 12h28M12 4v28"/></svg><p>Select a node in<br/>the Explorer to<br/>edit its properties</p></div>`;
    return;
  }
  lbl.textContent = node.type.toUpperCase();
  let h = '';
  if (node.locked) h += `<div class="plock"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.3"><rect x="2.5" y="5" width="7" height="6" rx=".5"/><path d="M4 5V3.5a2 2 0 014 0V5"/></svg>This node cannot be removed</div>`;
  h += sec('General', [pTxt('Label','label',node.props.label), ...(node.type!=='Audio'&&node.type!=='Background'?[pTgl('Visible','visible',node.props.visible)]:[])] );
  if (node.type === 'Background') {
    h += sec('Image',       [pFile('Image','src','image')]);
    h += sec('Adjustments', [pRng('Blur','blur',node.props.blur,0,40,'px'),pRng('Brightness','brightness',node.props.brightness,0,200,'%'),pRng('Saturation','saturation',node.props.saturation,0,200,'%'),pRng('Contrast','contrast',node.props.contrast,0,200,'%')]);
  } else if (node.type === 'Audio') {
    h += sec('Source',   [pFile('Audio File','src','audio'),`<div class="pr"><span class="pk"></span><div class="pv"><div id="audioLoadedBadge" class="audio-loaded" style="display:${node.props.src?'block':'none'}">✓ Audio loaded</div></div></div>`,pRng('Volume','volume',node.props.volume,0,100,'%')]);
    h += sec('Playback', [pRngF('Speed','speed',node.props.speed,0.25,4,0.05),pTglD('Pitch Sync','pitchSync',node.props.pitchSync,node.props.speed===1?'No effect at 1× speed':null),pTgl('Reverse','reverse',node.props.reverse)]);
    h += sec('Audio Cut', [pCut(node.props.cutStart, node.props.cutEnd)]);
  } else if (node.type === 'Visual Bar') {
    h += sec('Transform',  [pNum('X','x',node.props.x),pNum('Y','y',node.props.y),pNum('Width','width',node.props.width),pNum('Height','height',node.props.height)]);
    h += sec('Appearance', [pClr('Color','color',node.props.color),pRng('Opacity','opacity',node.props.opacity,0,100,'%')]);
    h += sec('Bars',       [pNum('Bar Count','barCount',node.props.barCount),pNum('Gap (px)','barGap',node.props.barGap),pNum('Max Height','maxHeight',node.props.maxHeight),pSel('Bar Type','barType',node.props.barType,['soft','wave','square','tower']),pSel('Formation','formation',node.props.formation,['line','circle'])]);
    h += sec('Audio Sync', [pRng('Intensity','intensity',node.props.intensity,0,200,'%'),pRng('Rotation','rotation',node.props.rotation,0,100,'%')]);
  } else if (node.type === 'Text') {
    h += sec('Transform', [pNum('X','x',node.props.x),pNum('Y','y',node.props.y),pNum('Width','width',node.props.width||400),pNum('Height','height',node.props.height||80)]);
    h += sec('Text',      [pTxt('Content','content',node.props.content),pNum('Font Size','fontSize',node.props.fontSize),pSel('Font','fontFamily',node.props.fontFamily,['Space Mono','Bebas Neue','DM Sans','Georgia','Courier New']),pClr('Color','color',node.props.color),pSel('Align','align',node.props.align,['left','center','right']),pRng('Opacity','opacity',node.props.opacity,0,100,'%')]);
  } else if (node.type === 'Particle') {
    h += sec('Transform',  [pNum('X','x',node.props.x),pNum('Y','y',node.props.y)]);
    h += sec('Particles',  [pNum('Count','count',node.props.count),pNum('Size','size',node.props.size),pClr('Color','color',node.props.color),pRng('Opacity','opacity',node.props.opacity,0,100,'%')]);
  } else if (node.type === 'Shape') {
    h += sec('Transform',  [pNum('X','x',node.props.x),pNum('Y','y',node.props.y),pNum('Width','width',node.props.width),pNum('Height','height',node.props.height)]);
    h += sec('Appearance', [pSel('Shape','shape',node.props.shape,['rectangle','circle','triangle']),pClr('Color','color',node.props.color),pRng('Corners','borderRadius',node.props.borderRadius,0,50,'%'),pRng('Opacity','opacity',node.props.opacity,0,100,'%')]);
  } else if (node.type === 'Gradient') {
    h += sec('Transform',  [pNum('X','x',node.props.x),pNum('Y','y',node.props.y),pNum('Width','width',node.props.width),pNum('Height','height',node.props.height)]);
    h += sec('Gradient',   [pClr('Color A','colorA',node.props.colorA),pClr('Color B','colorB',node.props.colorB),pSel('Direction','direction',node.props.direction,['horizontal','vertical','diagonal']),pRng('Opacity','opacity',node.props.opacity,0,100,'%')]);
  } else if (node.type === 'Image') {
    h += sec('Transform',  [pNum('X','x',node.props.x),pNum('Y','y',node.props.y),pNum('Width','width',node.props.width),pNum('Height','height',node.props.height)]);
    h += sec('Image',      [pFile('Source','src','image'),pRng('Opacity','opacity',node.props.opacity,0,100,'%')]);
  }
  body.innerHTML = h;

  body.querySelectorAll('.psec-title').forEach(t => {
    t.addEventListener('click', () => { t.classList.toggle('col'); t.nextElementSibling.classList.toggle('hid'); });
  });

  // Debounced history push for property changes
  let propHistTimer = null;
  body.querySelectorAll('[data-prop]').forEach(inp => {
    const upd = () => {
      const k = inp.dataset.prop; let v = inp.value;
      if (inp.type==='number')   v = parseFloat(v) || 0;
      if (inp.type==='checkbox') v = inp.checked;
      if (inp.type==='range') {
        v = parseFloat(v);
        const d = inp.parentElement.querySelector('.rval');
        if (d) d.textContent = inp.dataset.float ? parseFloat(v).toFixed(2)+'×' : v+(inp.dataset.unit||'');
      }
      node.props[k] = v;
      renderCanvas();
      if (k==='label') renderTree();
      if (k==='speed' || k==='pitchSync') renderProps(node);
      if (k==='volume' && gainNode) gainNode.gain.value = v / 100;
      // Push history after 600ms of no changes
      clearTimeout(propHistTimer);
      propHistTimer = setTimeout(pushHistory, 600);
    };
    inp.addEventListener('input', upd);
    if (inp.type==='number') inp.addEventListener('change', upd);
  });

  // Audio file picker
  body.querySelector('[data-file="audio"]')?.addEventListener('click', () => {
    const fi = document.createElement('input'); fi.type='file'; fi.accept='audio/*';
    fi.onchange = async e => {
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = async ev => {
        node.props.src = ev.target.result;
        await loadAudioBuffer(ev.target.result);
        const b = document.getElementById('audioLoadedBadge'); if (b) b.style.display = 'block';
        renderCanvas(); pushHistory();
      };
      reader.readAsDataURL(file);
    };
    fi.click();
  });

  body.querySelectorAll('[data-file="image"]').forEach(btn => {
    btn.addEventListener('click', () => {
      const fi = document.createElement('input'); fi.type='file'; fi.accept='image/*';
      fi.onchange = e => {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => { node.props.src = ev.target.result; renderCanvas(); pushHistory(); };
        reader.readAsDataURL(file);
      };
      fi.click();
    });
  });
}

/* prop helpers */
function sec(t,rows){ return `<div class="psec"><div class="psec-title"><svg width="8" height="8" viewBox="0 0 8 8" fill="currentColor"><path d="M2 1l4 3-4 3V1z"/></svg>${t}</div><div class="psec-body">${rows.join('')}</div></div>`; }
function pTxt(l,k,v){ return `<div class="pr"><span class="pk">${l}</span><div class="pv"><input type="text" data-prop="${k}" value="${esc(String(v))}"/></div></div>`; }
function pNum(l,k,v){ return `<div class="pr"><span class="pk">${l}</span><div class="pv"><input type="number" data-prop="${k}" value="${v}"/></div></div>`; }
function pClr(l,k,v){ return `<div class="pr"><span class="pk">${l}</span><div class="pv"><input type="color" data-prop="${k}" value="${v||'#000000'}"/></div></div>`; }
function pRng(l,k,v,mn,mx,u=''){ return `<div class="pr"><span class="pk">${l}</span><div class="pv"><div class="rwrap"><input type="range" data-prop="${k}" value="${v}" min="${mn}" max="${mx}" step="1" data-unit="${u}"/><span class="rval">${v}${u}</span></div></div></div>`; }
function pRngF(l,k,v,mn,mx,st=.1){ return `<div class="pr"><span class="pk">${l}</span><div class="pv"><div class="rwrap"><input type="range" data-prop="${k}" value="${v}" min="${mn}" max="${mx}" step="${st}" data-float="1"/><span class="rval">${parseFloat(v).toFixed(2)}×</span></div></div></div>`; }
function pTgl(l,k,v){ return `<div class="pr"><span class="pk">${l}</span><div class="pv"><div class="twrap"><label class="tgl"><input type="checkbox" data-prop="${k}" ${v?'checked':''}><div class="tgl-tr"></div><div class="tgl-th"></div></label></div></div></div>`; }
function pTglD(l,k,v,note){ const n=note?`<span style="font-family:'Space Mono',monospace;font-size:8px;color:var(--muted);display:block;margin-top:2px">${note}</span>`:''; return `<div class="pr" style="${note?'opacity:.45':''}"><span class="pk">${l}</span><div class="pv"><div class="twrap"><label class="tgl"><input type="checkbox" data-prop="${k}" ${v?'checked':''} ${note?'disabled':''}><div class="tgl-tr"></div><div class="tgl-th"></div></label></div>${n}</div></div>`; }
function pSel(l,k,v,opts){ return `<div class="pr"><span class="pk">${l}</span><div class="pv"><select data-prop="${k}">${opts.map(o=>`<option value="${o}"${o===v?' selected':''}>${o}</option>`).join('')}</select></div></div>`; }
function pFile(l,k,ft){ return `<div class="pr"><span class="pk">${l}</span><div class="pv"><button class="pfbtn" data-file="${ft}"><svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M1 7V9h8V7M5 1v6M2.5 3.5L5 1l2.5 2.5"/></svg>Choose File</button></div></div>`; }
function pCut(s,e){ const i=(l,pp,v)=>`<div style="display:flex;align-items:center;gap:6px"><span style="font-family:'Space Mono',monospace;font-size:9px;color:var(--muted2);width:30px;flex-shrink:0">${l}</span><input type="number" data-prop="${pp}" value="${v}" min="0" step=".1" style="flex:1;background:var(--panel2);border:1px solid var(--border);color:var(--white);font-family:'Space Mono',monospace;font-size:10px;padding:4px 7px;outline:none;user-select:text;-webkit-user-select:text"/><span style="font-family:'Space Mono',monospace;font-size:9px;color:var(--muted)">s</span></div>`; return `<div class="pr" style="align-items:flex-start;padding-top:8px"><span class="pk" style="padding-top:6px">Range</span><div class="pv"><div style="display:flex;flex-direction:column;gap:6px">${i('Start','cutStart',s)}${i('End','cutEnd',e)}<div style="font-family:'Space Mono',monospace;font-size:8px;color:var(--muted)">0 = disabled</div></div></div></div>`; }
function esc(s){ return s.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;'); }

/* ══════════════════════════════════════════════
   CONTEXT MENU
══════════════════════════════════════════════ */
function openCtx(e, id) {
  e.preventDefault(); e.stopPropagation(); ctxId = id; selectNode(id);
  const m = document.getElementById('ctx'); m.classList.add('on');
  m.style.left = Math.min(e.clientX, window.innerWidth-180)+'px';
  m.style.top  = Math.min(e.clientY, window.innerHeight-120)+'px';
}
function closeCtx() { document.getElementById('ctx').classList.remove('on'); }
document.getElementById('cxRen').addEventListener('click', ()=>{ const n=nodes.find(n=>n.id===ctxId); if(!n) return; const nm=prompt('Rename:',n.props.label); if(nm?.trim()){n.props.label=nm.trim();renderTree();if(selId===n.id)renderProps(n);pushHistory();} closeCtx(); });
document.getElementById('cxDup').addEventListener('click', ()=>{ dupeNode(ctxId); closeCtx(); });
document.getElementById('cxDel').addEventListener('click', ()=>{ deleteNode(ctxId); closeCtx(); });
document.addEventListener('click', e => {
  if (!document.getElementById('ctx').contains(e.target)) closeCtx();
});

/* ══════════════════════════════════════════════
   PANEL RESIZE
══════════════════════════════════════════════ */
function setupResize(hId, pId, dir) {
  const handle = document.getElementById(hId), panel = document.getElementById(pId);
  let sx, sw;
  handle.addEventListener('mousedown', e => {
    e.preventDefault(); sx=e.clientX; sw=panel.offsetWidth;
    handle.classList.add('drag'); document.body.classList.add('col-resize');
    const mv = e => { const d=dir==='left'?e.clientX-sx:sx-e.clientX; panel.style.width=Math.max(140,Math.min(520,sw+d))+'px'; resizeCanvas(); renderCanvas(); };
    const up = () => { handle.classList.remove('drag'); document.body.classList.remove('col-resize'); document.removeEventListener('mousemove',mv); document.removeEventListener('mouseup',up); };
    document.addEventListener('mousemove',mv); document.addEventListener('mouseup',up);
  });
}
setupResize('rhL','explorer','left');
setupResize('rhR','properties','right');

/* ══════════════════════════════════════════════
   TOAST & STATUS
══════════════════════════════════════════════ */
let toastTimer = null;
function toast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg; el.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => el.classList.remove('show'), 2500);
}
function updateStatus() { document.getElementById('snodes').textContent = `Nodes: ${nodes.length}`; }

/* ══════════════════════════════════════════════
   FFT COMPUTATION (for export)
   Real Cooley-Tukey FFT — accurate spectrum
══════════════════════════════════════════════ */
function computeFFT(signal) {
  const n = signal.length;
  if (n <= 1) return signal.map(v => ({ re:v, im:0 }));
  const out = new Array(n);
  // bit-reversal permutation
  const bits = Math.log2(n);
  for (let i = 0; i < n; i++) {
    let rev = 0, x = i;
    for (let b = 0; b < bits; b++) { rev = (rev<<1)|(x&1); x>>=1; }
    out[rev] = { re: signal[i], im: 0 };
  }
  // butterfly
  for (let len = 2; len <= n; len <<= 1) {
    const ang = -2*Math.PI/len;
    const wRe = Math.cos(ang), wIm = Math.sin(ang);
    for (let i = 0; i < n; i += len) {
      let cRe = 1, cIm = 0;
      for (let j = 0; j < len>>1; j++) {
        const uRe = out[i+j].re, uIm = out[i+j].im;
        const vRe = out[i+j+len/2].re*cRe - out[i+j+len/2].im*cIm;
        const vIm = out[i+j+len/2].re*cIm + out[i+j+len/2].im*cRe;
        out[i+j]       = { re:uRe+vRe, im:uIm+vIm };
        out[i+j+len/2] = { re:uRe-vRe, im:uIm-vIm };
        const nRe = cRe*wRe - cIm*wIm;
        cIm = cRe*wIm + cIm*wRe; cRe = nRe;
      }
    }
  }
  return out;
}

async function precomputeAllFrameFreqs(totalFrames, fps) {
  const fftSize  = 1024; // power of 2
  const binCount = fftSize >> 1;
  const raw      = audioBuffer.getChannelData(0);
  const sr       = audioBuffer.sampleRate;
  const result   = [];

  for (let f = 0; f < totalFrames; f++) {
    const sampleStart = Math.round(f * sr / fps);
    // Build windowed signal
    const signal = new Float32Array(fftSize);
    for (let i = 0; i < fftSize; i++) {
      // Hanning window
      const w = 0.5 * (1 - Math.cos((2*Math.PI*i)/(fftSize-1)));
      signal[i] = (raw[sampleStart + i] || 0) * w;
    }
    // FFT
    const spectrum = computeFFT(Array.from(signal));
    // Magnitude → 0–255
    const mag = new Uint8Array(binCount);
    for (let k = 0; k < binCount; k++) {
      const m = Math.sqrt(spectrum[k].re**2 + spectrum[k].im**2) / fftSize;
      mag[k] = Math.min(255, Math.round(m * 3200)); // scale to typical analyser output
    }
    result.push(mag);
    // Yield every 60 frames so the UI stays responsive
    if (f % 60 === 0) await new Promise(r => setTimeout(r, 0));
  }
  return result;
}

/* ══════════════════════════════════════════════
   DRAW A FULL FRAME TO A 2D CONTEXT (export)
══════════════════════════════════════════════ */
const _imgCache = {};
function loadImg(src) {
  if (_imgCache[src]) return Promise.resolve(_imgCache[src]);
  return new Promise((res, rej) => { const i=new Image(); i.onload=()=>{_imgCache[src]=i;res(i);}; i.onerror=rej; i.src=src; });
}

async function drawExportFrame(ctx, t, freq, EW, EH) {
  ctx.clearRect(0, 0, EW, EH);
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, EW, EH);
  // Background
  const bg = nodes.find(n => n.type==='Background');
  if (bg) {
    if (bg.props.src) {
      try {
        const img = await loadImg(bg.props.src);
        const fp  = buildCSSFilter(bg.props);
        if (fp) ctx.filter = fp;
        ctx.drawImage(img, 0, 0, EW, EH);
        ctx.filter = 'none';
      } catch {}
    }
    // Adjustments on solid colour are ignored (no image)
  }
  // Nodes
  const sX = EW/NW, sY = EH/NH;
  for (const node of nodes.filter(n => !n.locked && n.props.visible)) {
    const p = node.props;
    const cx = EW/2 + p.x*sX, cy = EH/2 + p.y*sY;
    ctx.globalAlpha = (p.opacity||100) / 100;
    if (node.type === 'Visual Bar') {
      drawVBarToCanvas(ctx, p, freq, EW, EH, NW, NH);
      ctx.globalAlpha = 1; continue;
    }
    if (node.type === 'Shape') {
      const w=p.width*sX, h=p.height*sY;
      ctx.fillStyle = p.color;
      ctx.save();
      if (p.borderRadius > 0) {
        const r = Math.min(w,h)*p.borderRadius/100;
        ctx.beginPath(); ctx.roundRect(cx-w/2,cy-h/2,w,h,r); ctx.fill();
      } else ctx.fillRect(cx-w/2, cy-h/2, w, h);
      ctx.restore();
    }
    if (node.type === 'Gradient') {
      const w=p.width*sX, h=p.height*sY;
      const gdirs = {
        horizontal: [cx-w/2, cy, cx+w/2, cy],
        vertical:   [cx, cy-h/2, cx, cy+h/2],
        diagonal:   [cx-w/2, cy-h/2, cx+w/2, cy+h/2],
      };
      const gd = gdirs[p.direction] || gdirs.horizontal;
      const g = ctx.createLinearGradient(...gd);
      g.addColorStop(0,p.colorA); g.addColorStop(1,p.colorB);
      ctx.fillStyle = g; ctx.fillRect(cx-w/2, cy-h/2, w, h);
    }
    if (node.type === 'Text') {
      ctx.fillStyle   = p.color;
      ctx.font        = `${p.fontSize*sX}px '${p.fontFamily}', monospace`;
      ctx.textAlign   = p.align || 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.content, cx, cy);
    }
    if (node.type === 'Image' && p.src) {
      try {
        const img = await loadImg(p.src);
        const w=p.width*sX, h=p.height*sY;
        ctx.drawImage(img, cx-w/2, cy-h/2, w, h);
      } catch {}
    }
    ctx.globalAlpha = 1;
  }
}

function buildCSSFilter(props) {
  const fp=[];
  if(props.blur>0)           fp.push(`blur(${props.blur}px)`);
  if(props.brightness!==100) fp.push(`brightness(${props.brightness}%)`);
  if(props.saturation!==100) fp.push(`saturate(${props.saturation}%)`);
  if(props.contrast!==100)   fp.push(`contrast(${props.contrast}%)`);
  return fp.join(' ');
}

/* ══════════════════════════════════════════════
   EXPORT  —  video + audio, frame-accurate
══════════════════════════════════════════════ */
let exportCancelFlag = false;

function startExport() {
  if (!audioBuffer) { toast('⚠ Load an audio file before exporting'); return; }
  exportCancelFlag = false;
  document.getElementById('expModal').classList.add('on');
  runExport().catch(err => {
    console.error('Export error:', err);
    document.getElementById('expModal').classList.remove('on');
    toast('⚠ Export failed: ' + err.message);
  });
}
function cancelExport() {
  exportCancelFlag = true;
  document.getElementById('expModal').classList.remove('on');
}

async function runExport() {
  const fps  = 30;
  const dur  = audioDuration;
  const EW   = NW, EH = NH;            // Export at exact design resolution
  const totalFrames = Math.ceil(dur * fps);

  const setUI = (pct, status) => {
    document.getElementById('expFill').style.width = pct+'%';
    document.getElementById('expPct').textContent  = Math.round(pct)+'%';
    document.getElementById('expStatus').textContent = status;
  };

  /* ── STEP 1: Pre-compute FFT for every frame ── */
  document.getElementById('expSub').textContent = `${EW}×${EH} · ${fps}fps · ${dur.toFixed(1)}s · ${totalFrames} frames`;
  setUI(0, 'Computing frequency data…');

  const allFreqs = await precomputeAllFrameFreqs(totalFrames, fps);
  if (exportCancelFlag) return;
  setUI(15, 'Frequency data ready');

  /* ── STEP 2: Offscreen canvas ── */
  const offCanvas = document.createElement('canvas');
  offCanvas.width = EW; offCanvas.height = EH;
  const offCtx = offCanvas.getContext('2d');

  /* ── STEP 3: Export audio context → MediaStreamDestination ──
     This creates a real-time audio stream that gets recorded
     with the exact same timing as the video.  */
  const expAudioCtx  = new AudioContext({ sampleRate: audioBuffer.sampleRate });
  const expDest      = expAudioCtx.createMediaStreamDestination();
  const expGain      = expAudioCtx.createGain();
  expGain.gain.value = 1.0;
  expGain.connect(expDest);
  const expSrc       = expAudioCtx.createBufferSource();
  expSrc.buffer      = audioBuffer;
  expSrc.connect(expGain);

  /* ── STEP 4: Combine video + audio tracks ── */
  // captureStream(fps) captures canvas at exactly fps in realtime
  const videoStream  = offCanvas.captureStream(fps);
  expDest.stream.getAudioTracks().forEach(t => videoStream.addTrack(t));

  /* ── STEP 5: MediaRecorder ── */
  const mimeTypes = [
    'video/webm;codecs=vp9,opus',
    'video/webm;codecs=vp8,opus',
    'video/webm;codecs=vp9',
    'video/webm',
  ];
  const mimeType = mimeTypes.find(m => MediaRecorder.isTypeSupported(m)) || 'video/webm';
  const recorder = new MediaRecorder(videoStream, { mimeType, videoBitsPerSecond: 12_000_000 });
  const chunks   = [];
  recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };

  /* ── STEP 6: Start audio + recorder simultaneously ──
     Both start at the same moment so audio perfectly syncs to video. */
  setUI(15, 'Starting encoder…');
  recorder.start(100); // request data every 100ms
  expSrc.start(0);
  const exportStartWall = performance.now();

  /* ── STEP 7: Render each frame, paced to exactly 1000/fps ms ──
     We sleep(frameMs) between frames so captureStream captures
     one frame per slice, giving the correct video duration. */
  const frameMs = 1000 / fps;
  for (let f = 0; f < totalFrames; f++) {
    if (exportCancelFlag) {
      try { expSrc.stop(); } catch {}
      recorder.stop(); expAudioCtx.close(); return;
    }
    const t = f / fps;
    // Draw frame synchronously
    await drawExportFrame(offCtx, t, allFreqs[f], EW, EH);
    // Update progress (15–98%)
    setUI(15 + (f / totalFrames) * 83, `Frame ${f+1} / ${totalFrames}  (${fmt(t)})`);
    // Pace the loop: sleep until the wall-clock time this frame should occur.
    // This keeps captureStream from duplicating or skipping frames.
    const targetWall = exportStartWall + (f + 1) * frameMs;
    const delay = targetWall - performance.now();
    if (delay > 0) await new Promise(r => setTimeout(r, delay));
  }

  /* ── STEP 8: Finalise ── */
  setUI(98, 'Encoding…');
  try { expSrc.stop(); } catch {}
  // Give recorder time to flush remaining audio (at least one audio buffer)
  await new Promise(r => setTimeout(r, 500));

  await new Promise(resolve => {
    recorder.onstop = () => {
      const blob = new Blob(chunks, { type: mimeType });
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement('a');
      const pname = (document.getElementById('projName').value || 'audiviz').replace(/[^a-z0-9_-]/gi,'_');
      a.href = url; a.download = `${pname}.webm`; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 5000);
      resolve();
    };
    recorder.stop();
  });

  await expAudioCtx.close();
  document.getElementById('expModal').classList.remove('on');
  setUI(100, 'Done!');
  toast(`✓ Export complete — ${fmt(dur)} video saved`);
}

/* ══════════════════════════════════════════════
   BOOT
══════════════════════════════════════════════ */
init();
</script>
</body>
</html>
